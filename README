# we must initilaize the storage directory
$ plash-init

# build a simple image
$ plash-build --image alpine --run 'touch /file'
[0%|10%|20%|30%|40%|50%|60%|70%|80%|90%|100%]
extracting...
--> touch /file
--:
2

# second build is cached
$ plash-build --image alpine --run 'touch /file'
2

# run something inside a container
$ plash-run 2 ls /file
/file

# layering is explicit
$ plash-build --image alpine --run 'touch /file' --layer --run 'touch /file2'
--> touch /file2
--:
3

# delete a container
$ plash-rm 3

# build and run in one command
$ plash-run --image alpine --run 'touch /file' -- ls /file
/file

# you can easily mount, execute a command on the filesystem, then unmount.
$ plash-with-mount --image alpine -- ls
bin  etc   lib	  mnt	root  sbin  sys  usr
dev  home  media  proc	run   srv   tmp  var
$ plash-with-mount -i alpine -- chroot . /bin/sh
/ # exit

# plash actually includes some configuration management 
$ plash-run --image alpine --apk git -- git --version
--> apk update
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz
v3.7.0-61-g66a2eadbb3 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main]
v3.7.0-58-g26701b74f8 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community]
OK: 9044 distinct packages available
--> apk add git
(1/6) Installing ca-certificates (20171114-r0)
(2/6) Installing libssh2 (1.8.0-r2)
(3/6) Installing libcurl (7.57.0-r0)
(4/6) Installing expat (2.2.5-r0)
(5/6) Installing pcre2 (10.30-r0)
(6/6) Installing git (2.15.0-r1)
Executing busybox-1.27.2-r8.trigger
Executing ca-certificates-20171114-r0.trigger
OK: 21 MiB in 22 packages
--:
git version 2.15.0

$ echo '#!/usr/bin/env plash-exec
> # plash-exec: exec=fzf
> --image
> alpine
> --apk
> wget
> --run
> cd $(mktemp -d)
> wget -q https://github.com/junegunn/fzf-bin/releases/download/0.17.3/fzf-0.<m/junegunn/fzf-bin/releases/download/0.17.3/fzf-0.1                         7.3-linux_amd64.tgz
> tar xvzf *.tgz
> cp fzf /usr/local/bin/fzf' > /tmp/fzf

$ chmod +x /tmp/fzf
$ /tmp/fzf --version
--> apk update
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz
fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz
v3.7.0-61-g66a2eadbb3 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main]
v3.7.0-58-g26701b74f8 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community]
OK: 9044 distinct packages available
--> apk add wget
(1/1) Installing wget (1.19.2-r1)
Executing busybox-1.27.2-r8.trigger
OK: 7 MiB in 17 packages
--> mktemp -d
--> cd /tmp/tmp.jIGiEm
--> wget -q https://github.com/junegunn/fzf-bin/releases/download/0.17.3/fzf-0.17.3-linux_amd64.tgz
--> tar xvzf fzf-0.17.3-linux_amd64.tgz
fzf
--> cp fzf /usr/local/bin/fzf
--:
0.17.3 (390b496)

$ exit
exit


########
## DRAFT
#######


Plash
is a container build and runtime system.

install
python3 -m pip install https://github.com/ihucos/plash/archive/master.zip

Documentation
This README
Reference: <link coming soon>.
More being written.


Why Plash?

- Runs anywhere.
Plash's only requirements are python3, a linux kernel (>= 3.18) and a
rudimentary mount binary in $PATH. It does not need an extra daemon and can be
easily run in infrastructure not meant to support containers like virtually any
ci environment, embedded systems or even docker containers.

- Flexibility
You can mount a container filesystem, export/import docker images, run
containers as chrooted processes or runc, directly add a raw layer o top of a
container, save containers by a cache key and much more.

- Its just processes
Plash containers are processes exactly like you know them. They can be listed
with ps, `kill`ed, you can filter for stderr or pipe to stdin, manage them in
groups with `supervisord` and `runit` or simply access files in your home directory.
Only parts of the filesystem are isolated. If you need more isolation, use
another tool just for that or run containers "traditionally" with plash-runc.

- Plashfiles
Plashfiles are executable build files featuring optional
lightweight configuration management capabilities.

Example session: {{ EXAMPLE_HERE }}


Security
Plash's default container runtime does come with a security concept. It does
not try to reinvent any security layer but to only rely on traditional UNIX
security mechanisms. Figuratively speaking plash does not try to barricade
processes with tape. Inside a container a user is what he was outside of it.
As far as the kernel cares the only difference between a container and a
"normal" process is that the container is chrooted. Access rights established
outside of the container are still valid inside. So in fact to install software
with a package manager inside a container you probably need root, but to later
run it not. It can be seen as a one to one mapping between host and container.

There is some fine print: Root access is needed for container setup. In the
future the plan is to use suid binaries to archive this. At the moment this
is done with sudo. To allow a user to use plash put this is the suoders file
`joe ALL=NOPASSWD: /usr/local/bin/plash-run`. This should be considered unsafe
until version 1.0.

Plashfiles
TODO

Philosophy
Plash thrives to not be more than a useful tool. There is no monetization
strategy, bundling or closed source. It plays well with other software in the
ecosystem. Plash and its internal architecture tries to honor the "Do One Thing
and Do It Well" UNIX philosophy. This software tries to not "oversell" its
abstraction layer, which is containerization of processes. Containerization and
isolation are seen as two different tasks, but as a flexible tool this software
does not enforce any specific why of using it. Sloppily speaking: after we had
a revolutionary containerization of processes with docker, this is also some
needed fine adjusting: a <b>processisation of containers</b>.

Plash tries to be very maintainable and is designed to still securely run
without any changes in 5 or 10 years. This software tries to be in every aspect
of the word lightweight. For example covering less complicated use cases for

containers, like letting a user quickly use a newer software package from
another distribution in a sane way. Or being easy to install. Last but not
least in a new and fast-moving container world the focus is on boring long term
stability and backwards compatibility, starting from version 1.0.

FAQ
TODO
