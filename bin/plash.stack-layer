import errno
import os
import sys
from os.path import join
from subprocess import CalledProcessError, Popen, check_call, check_output
from tempfile import mkdtemp

from plash.utils import catch_and_die, hashstr, die

BASE_DIR = '/var/lib/plash'

container = sys.argv[1]
cmd = sys.argv[2]
quiet = False

with catch_and_die([CalledProcessError]):
    node_path = check_output(['plash.nodepath', container])
    node_path = node_path.decode().strip('\n')

new_child = mkdtemp(dir=join(BASE_DIR, 'tmp'))
mountpoint = mkdtemp(dir=join(BASE_DIR, 'tmp'))
new_layer = join(new_child, 'payload')
os.mkdir(new_layer)
os.mkdir(join(new_child, 'children'))

with catch_and_die([CalledProcessError]):
    check_call(['plash.mount', container, mountpoint, '--upperdir', new_layer])

with catch_and_die([CalledProcessError]):
    check_call(['mount', '-t', 'proc', 'proc', join(mountpoint, 'proc')])
    check_call(['mount', '--bind', '/home', join(mountpoint, 'home')])
    check_call(['mount', '--bind', '/sys', join(mountpoint, 'sys')])
    check_call(['mount', '--bind', '/dev', join(mountpoint, 'dev')])
    check_call(['mount', '-t', 'tmpfs', 'tmpfs', join(mountpoint, 'tmp')])
    check_call([
        'mount', '--bind', '/etc/resolv.conf',
        join(mountpoint, 'etc/resolv.conf')
        ])

def preexec_fn():
    os.chroot(mountpoint)
    os.chdir("/")
    os.close(
        0
    )  # close stdin for more reproducible builds - if that does not work well, there is another way

if quiet:
    out = DEVNULL
else:
    out = 2  # stderr
p = Popen(
    ['sh', '-cxe', cmd], stderr=out, stdout=out, preexec_fn=preexec_fn)
child_exit = p.wait()

with catch_and_die([CalledProcessError]):
    check_call(['umount', '--lazy', '--recursive', mountpoint])

if child_exit != 0:
    atexit.register(lambda: shutil.rmtree(new_child))
    raise BuildError(
        "build returned exit status {}".format(child_exit))

new_container_id = hashstr(b':'.join([container.encode(), cmd.encode()]))
final_child_dst = join(join(BASE_DIR, 'builds'), node_path, 'children', new_container_id)

try:
    os.symlink(final_child_dst, join(BASE_DIR, 'links', new_container_id))
except FileExistsError:
    pass

try:
    os.rename(new_child, final_child_dst)
except OSError as exc:
    if exc.errno == errno.ENOTEMPTY:
        die('container id or layer {} already exists'.format(new_container_id))
    else:
        raise

print(new_container_id)
