#!/usr/bin/env python3
# vim: set filetype=python:
#
# usage: plash-run CONTAINER [--workdir VALUE] [--upperdir VALUE] [--dont-deescalate] [CMD1 [CMD2 [CMD3 ...]]
# usage: plash-run --ps
# Run a command inside the container. If no command is specified a shell is started.
# The workdir and upperdir parameters can be used to save file system changes made inside the container.


import argparse
from time import sleep
import atexit
import os
import sys
import tempfile
from os.path import join, isdir
from subprocess import CalledProcessError, call, check_call

from plashlib.utils import catch_and_die, deescalate_sudo, die, die_with_usage, handle_help_flag

MOUNT_IF_EXISTS_IN_HOST = ['/home', '/Users']

handle_help_flag()

#  list running/mounted processes if desired
if sys.argv[1:3] == ['--ps']:
    import re
    with open('/proc/mounts') as f:
        for entry in re.finditer(
	        '^overlay /var/tmp/plash-run/(.*?) ',
	        f.read(),
	        flags=re.MULTILINE):
            pid = entry.group(1)
            try:
                with open('/proc/{}/cmdline'.format(pid)) as p:
                    container_name = p.read().replace('\0', ' ')
            except FileNotFoundError:
                container_name = '<no cleanup>'
            print('{} {}'.format(pid, container_name))
    sys.exit(0)

workdir = None
upperdir = None
deescalate = True
try:
    container, *cmd = sys.argv[1:]
    while True:
        if not cmd:
            break
        if cmd[0] == '--workdir':
            cmd.pop(0)
            workir = cmd.pop(0)
        elif cmd[0] == '--upperdir':
            cmd.pop(0)
            upperdir = cmd.pop(0)
        elif cmd[0] == '--dont-deescalate':
            cmd.pop(0)
            deescalate = False
        elif cmd[0] == '--':
            cmd.pop(0)
            break
        else:
            break
    if container.startswith('-') or cmd and cmd[0].startswith('-'):
        raise ValueError()
except (IndexError, ValueError):
    die_with_usage()



main_pid = os.getpid()
mountpoint = join('/var/tmp/plash-run', str(main_pid))
os.makedirs(mountpoint, 0x007, exist_ok=True)

exit = call(['plash-mount', container, mountpoint] + ([
    '--workdir', workdir
] if workdir else []) + (['--upperdir', upperdir] if upperdir else []))
if exit:
    sys.exit(exit)

# write a /plashenv file
with open(join(mountpoint, 'plashenv'), 'w') as f:
    f.write(container + '\n')

uid = int(os.environ.get('SUDO_UID') or os.getuid())

mounts = ['proc', 'sys', 'dev', 'tmp', 'etc/resolv.conf']
mounts_map = dict((m, join(mountpoint, m.lstrip('/'))) for m in mounts)
for m in MOUNT_IF_EXISTS_IN_HOST:
    if os.path.exists(m):
        mounts_map[m] = join(mountpoint, m.lstrip('/'))
        try:
            os.makedirs(mounts_map[m]) # FIXME: directory access rights, maybe
        except FileExistsError:
            pass
        with catch_and_die([CalledProcessError]):
            check_call(['mount', '--bind', m, mounts_map[m]])

with catch_and_die([CalledProcessError]):
    check_call(['mount', '-t', 'proc', 'proc', mounts_map['proc']])
    check_call(['mount', '--rbind', '/sys', mounts_map['sys']])
    check_call(['mount', '--bind', '/dev', mounts_map['dev']])
    check_call(['mount', '--bind', '/tmp', mounts_map['tmp']])
    check_call([
        'mount', '--bind', '/etc/resolv.conf',
        mounts_map['etc/resolv.conf']
    ])

#
# start a child process to cleanup when its parent dies
#
if not os.fork():
    os.setsid()  # makes this is kind of a standalone "daemon" process, not more inherit the signal processing
    os.close(1)  # really weird, we need to close stdout or another process calling this via check_output will block forever
    #os.setpgrp()  # that fixes that the called process waits for all its childs to finish
    # fork and exit so the child gets 1 as the parent id, which solves blocking if the main process exec waits for its children.
    if os.fork():
       sys.exit(0)
    else:
       while True:
           sleep(5)
           parent_dead =  not isdir(join('/proc', str(main_pid)))
           if parent_dead:
               print('die die die', file=sys.stderr)
               with catch_and_die([CalledProcessError]):
                   for mp in mounts_map.values():
                          check_call(['umount', '-l', mp])
                   check_call(['umount', '-l', mountpoint])
               sys.exit(0)

pwd = os.getcwd()
os.chroot(mountpoint)
os.chdir('/')

with open('/etc/passwd') as f:
    #  the first entry is the root entry
    #  https://security.stackexchange.com/questions/96241/why-require-root-to-be-the-first-entry-in-etc-passwd
    root_entry = f.readline().rstrip('\n')
    default_root_shell = root_entry.split(":")[6]
if not cmd:
    cmd = [default_root_shell]

os.chmod('/', 0o755) # not so sure if this here or more to the top
if deescalate:
    deescalate_sudo()
try:
    os.chdir(pwd)
except (ValueError, PermissionError, FileNotFoundError): # TODO: put more exceptions here
    os.chdir("/")
try:
    os.execvpe(cmd[0], cmd, os.environ)
except FileNotFoundError:
    die('Command not found: {}'.format(cmd[0]))
