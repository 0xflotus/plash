#!/usr/bin/env python3
#
# usage: plash-add-layer CONTAINER
# Reads a shell script from stdin and returns a builded or cached container on top of the supplied container.
# The new container is the only thing printed to stdout, building information and status messages are printed to stderr.
# For most cases use `plash build` for a higher level interface.
#
# Exit status:
# Same as `plash build`


import atexit
import errno
import os
import shutil
import subprocess
import sys
from os.path import basename, join
from subprocess import (DEVNULL, CalledProcessError, Popen, check_call,
                        check_output)
from sys import exit
from tempfile import mkdtemp

from plashlib.utils import catch_and_die, color, die, hashstr, info, call_plash_nodepath, die_with_usage, handle_help_flag


PLASH_DATA = os.environ.get('PLASH_DATA', '/var/lib/plash')

handle_help_flag()

try:
    container = sys.argv[1]
except IndexError:
    die_with_usage()

node_path = call_plash_nodepath(container)

new_container = hashstr(os.urandom(100))[:12]
final_child_dst = join(
    join(PLASH_DATA, 'builds'), node_path, 'children', new_container)

linkname = join(PLASH_DATA, 'links', new_container)
with catch_and_die([OSError], debug='symlink'):
    os.symlink(final_child_dst, linkname)

new_child = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
mountpoint = mkdtemp(dir=join(PLASH_DATA, 'tmp'))
new_layer = join(new_child, 'payload')
os.mkdir(new_layer)
os.mkdir(join(new_child, 'children'))

p = subprocess.Popen(
    ['plash-run', container, '--dont-deescalate', '--upperdir', new_layer, 'sh'],
    env=os.environ,
    cwd='/')
exit = p.wait()

with catch_and_die(OSError):
    os.rename(new_child, final_child_dst)

print(new_container)
