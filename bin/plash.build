#!/usr/bin/python3
from plash.utils import setup_sigint_handler; setup_sigint_handler()

import argparse
import os
import platform
import shlex
import subprocess
import sys
from json import dumps
from subprocess import CalledProcessError, list2cmdline
from urllib.error import URLError

from plash import core, dockercore, state
from plash.core import BuildError, ImageNotFound, prepare_image
from plash.dockercore import DockerBuildError, docker_get_image_shell
from plash.eval import ActionNotFoundError, ArgError, EvalError, eval, layer
from plash.utils import (deescalate_sudo_call, die, disable_friendly_exception,
                         friendly_exception, hashstr, info, rand)

HELP = 'my help'

NO_TERM_BUILD_ERROR = """plash error: Refusing to build when not connected to a tty(-like) device.
Set the env PLASH_BUILD_SILENT to enable building without output is such cases.
Or invoke this call with --build-only from a terminal to build and then run again.
The argv of this program was: {}""".format(sys.argv)

# shortcuts are specific to the stdlib
SHORTCUTS = [
    # shortcut, lsp, nargs
    ('-x', ['run'], '+'),
    ('-a', ['apt'], '+'),
    ('-y', ['yum'], '+'),
    ('-p', ['pip'], '+'),
    ('-b', ['apt', 'ubuntu-server'], 0),
    ('-o', ['os'], 1),
    ('-r', ['include', '~/.plashrc'], 0),
    ('-U', ['os', 'ubuntu'], 0),
    ('-F', ['os', 'fedora'], 0),
    ('-D', ['os', 'debian'], 0),
    ('-l', ['layer'], 0),
    ('-i', ['include'], '+'),
 ]

def add_shortcuts_to_parser(parser):
    group = parser.add_argument_group('shortcuts', 'shortcuts')
    for shortcut, lsp, nargs in SHORTCUTS:
        group.add_argument(
            shortcut,
            action=create_collect_lsp_action(lsp),
            nargs=nargs)

def create_collect_lsp_action(lsp_begin):
    class CollectAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            if not 'lsp' in namespace:
                setattr(namespace, 'lsp', [])
            previous = namespace.lsp
            previous.append(lsp_begin + list(values))
            setattr(namespace, 'lsp', previous) 
    return CollectAction


class CollectEnvsAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        for value in values:
            if not getattr(namespace, self.dest):
                setattr(namespace, self.dest, {})
            key, value = value.split('=', 1)
            getattr(namespace, self.dest)[key] = value

def get_argument_parser():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawTextHelpFormatter,
        description='Plash is a container build system',
        prog='plash',
        epilog=HELP)

    parser.add_argument("--quiet", action='store_true')
    parser.add_argument("--mute", action='store_true')
    parser.add_argument("--no-stdlib", action='store_true')
    parser.add_argument("--traceback", action='store_true')
    parser.add_argument("--debug-lsp", action='store_true')
    parser.add_argument("--debug-script", action='store_true')
    parser.add_argument("--all-root", action='store_true')

    add_shortcuts_to_parser(parser)

    return parser


def main():

    if os.getuid():
        die("Need to be root")

    argv = sys.argv[1:]

    try:
        delimiter = argv.index('--')
        command = argv[delimiter+1:]
        argv = argv[:delimiter]
    except ValueError:
        command = None

    ap = get_argument_parser()
    _, unused_args = ap.parse_known_args(argv)
    # lsp = unused_args_to_lsp(unused_args)
    for arg in set(unused_args):
        if arg == '--':
            break
        if arg.startswith('--'):
            ap.add_argument(
                arg,
                action=create_collect_lsp_action([arg[2:]]),
                nargs='*')

    args = ap.parse_args(argv)

    if args.mute:
        sys.stderr = open('/dev/null', 'w')

    if args.traceback:
        disable_friendly_exception()

    lsp = getattr(args, 'lsp', [])

    if not args.no_stdlib:
        init = [['import', 'plash.stdlib']]
    else:
        init = []

    if args.debug_lsp:
        print(dumps(init + lsp), file=sys.stderr)
        sys.exit(1)
    with friendly_exception([ActionNotFoundError, ArgError, EvalError]):

        def deescalated():
            script = eval(init+lsp)
            return state.get_os(), script
        base_container, script = deescalate_sudo_call(deescalated) if not args.all_root else deescalated()
    
    if args.debug_script:
        print(script, file=sys.stderr)
        sys.exit(1)

    if not base_container:
        ap.error('Specify a base container')
    if script:
        layers = (script + '\n').split(layer() + '\n')
        layers = [l for l in layers if l]
    else:
        layers = []

    with friendly_exception([PermissionError, URLError, BuildError]):
        if base_container.endswith('.'): # its a sname
            c = core.Container.by_sname(base_container)
        else:
            with friendly_exception([ImageNotFound]):
                prepare_image(base_container)
            c = core.Container.by_lname(base_container)
        cache_hits = []
        for counter, cmd in enumerate(layers):
            on_build = lambda: info('Layer {}/{}'.format(counter+1, len(layers)))
            used_cache = c.add_or_build_layer(cmd, on_build=on_build, quiet=args.quiet or args.mute)
            cache_hits.append(used_cache)
        if not all(cache_hits):
            info('Done')
        c.log_access()
        print(c.sname)


if __name__ == '__main__':
    main()
