#!/usr/bin/env python3
#
# usage: plash-exec file [arg1 [arg2 [arg3 ...]]]
# Used as shebang. It runs a plash buildfile.

import os, sys, subprocess
from plashlib.utils import handle_help_flag, die_with_usage, die, catch_and_die, assert_initialized
from plashlib.eval import get_hint_values
import plashlib

handle_help_flag()
assert_initialized()

try:
    file, args = sys.argv[1], sys.argv[2:]
except ValueError:
    die_with_usage()


libdir = os.path.dirname(plashlib.__file__)
libexec = os.path.join(libdir, 'libexec')
os.environ['PATH'] = '{}:{}'.format(libexec, os.environ['PATH'])

with open(file) as f:
    script = f.read()

with catch_and_die([subprocess.CalledProcessError], silent=True):
    build_shell_script = subprocess.run(['plash-eval'],
        input=script.encode(), stdout=subprocess.PIPE, check=True
        ).stdout.decode()

hint_values = get_hint_values(build_shell_script)

exec = hint_values.get('exec')
if exec is None:
    die("no hint named 'exec' found (maybe try adding `--exec /bin/sh`)")

run_args = [exec] + args


with catch_and_die([subprocess.CalledProcessError], silent=True):
    run_container = subprocess.run(['plash-build-sh'],
        input=build_shell_script.encode(), stdout=subprocess.PIPE, check=True
        ).stdout.decode().strip('\n')


cmd = [
    'plash-run',
    'plash-run',
    run_container, '--'] + run_args

os.execlp(*cmd)
