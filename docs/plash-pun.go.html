<html>
<head>
<title>plash's command reference</title>
<link href="https://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet">
<link rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/gruvbox-dark.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>
hljs.initHighlightingOnLoad();
</script>
<style>
body {
  font-family: 'Inconsolata', monospace;
  margin: 0px;
}
code {
  font-size: 0.85em;
  text-align: left;
}
pre {
  margin: 0px;
}
#doc {
  min-height: 66.66vh;
  font-size: 1.25em;
  text-align: left;
  margin-top: 2.5em;
  margin-left: 4em;
  margin-bottom: 4em;
  color: #212845;
}

a {
  color: #212845;
  text-decoration: none;
}
a:link {
  color: #212845;
  text-decoration: none;
}
a:visited {
  color: #212845;
  text-decoration: none;
}
a:hover {
  color: #212845;
  text-decoration: none;
}
a:active {
  color: #212845;
  text-decoration: none;
}

#command-index {
  font-weight: bold;
}
h1 {
  margin-bottom: 0em;
}
</style>
</head>
<body>

<a href="https://github.com/ihucos/plash/blob/master/bin/plash-pun.go"><img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png"></a>


<center>

<div id='doc'>
<pre>
<h1>plash-pun.go</h1>



<a href='index.html' id='command-index'>&larr; Command index</a>
</pre>
</div>

<div id="container">
<pre>
<code>package main

import &#34;syscall&#34;
import &#34;bytes&#34;
import &#34;os&#34;
import &#34;io/ioutil&#34;
import &#34;os/exec&#34;
import &#34;fmt&#34;
import &#34;strconv&#34;
import &#34;path/filepath&#34;
import &#34;path&#34;
import &#34;runtime&#34;

// think of a reason for a specific exit code number
const ERROR_EXIT_NUMBER = 120

const ERR_SETREUID_CONTEXT = &#34;call setreuid(0, 0)&#34;
const ERR_SETREUID_HINT = &#34;Run as root or set suid bit&#34;

const ERR_READ_BOOT_ID_CONTEXT = &#34;read the file /proc/sys/kernel/random/boot_id&#34;
const ERR_READ_BOOT_ID_HINT = &#34;Maybe /proc is not mounted&#34;

const ERR_READ_PLASH_ID_CONTEXT = &#34;read the file /var/lib/plash/id&#34;
const ERR_READ_PLASH_ID_HINT = &#34;run plash-init&#34;

const ERR_TMP_DIR_CONTEXT = &#34;create temporary directory in /var/tmp&#34;
const ERR_TMP_DIR_HINT = &#34;&#34;

const ERR_READLINK_CONTEXT = &#34;readlink %s&#34;
const ERR_READLINK_HINT = &#34;&#34;

const ERR_SYMLINK_CONTEXT = &#34;create symlink from %s to %s&#34;
const ERR_SYMLINK_HINT = &#34;&#34;

const ERR_GETWD_CONTEXT = &#34;get current directory&#34;
const ERR_GETWD_HINT = &#34;&#34;

const ERR_CHROOT_CONTEXT = &#34;crhoot into container filesystem at %s&#34;
const ERR_CHROOT_HINT = &#34;&#34;

const ERR_CHDIR_ROOT_CONTEXT = &#34;chdir to / after chroot into container&#34;
const ERR_CHDIR_ROOT_HINT = &#34;&#34;

const ERR_EXEC_CONTEXT = &#34;exec inside container&#34; 
const ERR_EXEC_HINT = &#34;&#34;

func isint(val string) bool {
	if _, err := strconv.Atoi(val); err == nil {
		return true
	}
	return false
}

func call(name string, arg ...string) {
	err := exec.Command(name, arg...).Run()
	if err != nil {
		panic(err)
	}
}

func checkErr(err error, contextMsg string, hint string) {
        if err != nil { 
            fmt.Fprintf(os.Stderr, &#34;plash-pun: error: %s\n&#34;, err.Error())
            fmt.Fprintf(os.Stderr, &#34;plash-pun: at: %s\n&#34;, contextMsg)
            if (hint != &#34;&#34;){
                fmt.Fprintf(os.Stderr, &#34;plash-pun: hint: %s:\n&#34;, hint)
            }
            os.Exit(ERROR_EXIT_NUMBER)
        }
}

func pathExists(path string) (bool) {
        _, err := os.Stat(path)
        if err == nil { return true }
        if os.IsNotExist(err) { return false }
        panic(err)
}
func main() {

        if len(os.Args) &lt; 2 {
                fmt.Fprint(os.Stderr, &#34;plash-pun: usage: plash-pun CONTAINER_ID [CMD1, [CMD2 ...]]\n&#34;)
                os.Exit(ERROR_EXIT_NUMBER)
        } 
	if !isint(os.Args[1]) {
		fmt.Fprint(os.Stderr, &#34;plash-pun: first argument must be an integer container id\n&#34;)
                os.Exit(ERROR_EXIT_NUMBER)
	}
	container := os.Args[1]
        cmd := os.Args[2:]
        if len(cmd) == 0 {
                // open default root terminal with sh
                cmd = []string{&#34;sh&#34;, &#34;-c&#34;, &#34;$(head -n1 /etc/passwd | cut -d: -f7)&#34;}
        }

        // Think three times before removing this line.
        // without it, chroot could be executed in a thread that still is root.
        // That would be a privilege escalation
        runtime.LockOSThread() 

        callerUid := syscall.Getuid()
        err := syscall.Setreuid(0, 0);
        checkErr(err, ERR_SETREUID_CONTEXT, ERR_SETREUID_HINT)

        // the mountpoint to chroot into
        bootId, err := ioutil.ReadFile(&#34;/proc/sys/kernel/random/boot_id&#34;);
        checkErr(err, ERR_READ_BOOT_ID_CONTEXT, ERR_READ_BOOT_ID_HINT)

        plashId, err := ioutil.ReadFile(&#34;/var/lib/plash/id&#34;)
        checkErr(err, ERR_READ_PLASH_ID_CONTEXT, ERR_READ_PLASH_ID_HINT)

        runData := &#34;/var/run/plash-pun&#34;
        tmp = fmt.Sprintf(&#34;/var/run/plash-pun-%s-%s-%s&#34;, bootId, plashId, container)
        finalMountpoint := fmt.Sprintf(&#34;/var/run/plash-pun-%s-%s-%s&#34;, bootId, plashId, container)

        //
        // populate mountpoint, if not done yet
        //
        if ! pathExists(finalMountpoint){
                
                mountpoint, err := ioutil.TempDir(&#34;/var/tmp&#34;, &#34;plash-run-suid-mountpoint-&#34;)
                checkErr(err, ERR_TMP_DIR_CONTEXT, ERR_TMP_DIR_HINT)
                indexLink := fmt.Sprintf(&#34;/var/lib/plash/index/%s&#34;, container)
                topLayer, err := os.Readlink(indexLink);
                checkErr(err, fmt.Sprintf(ERR_READLINK_CONTEXT, indexLink), ERR_READLINK_HINT)

                // generate the overlay options for mount
                var buffer bytes.Buffer
                buffer.WriteString(&#34;lowerdir=&#34;)
                first := true
                for {
                        cont := filepath.Base(topLayer)
                        topLayer = filepath.Dir(topLayer)
                        if !isint(cont) {
                                break
                        }
                        if !first {
                                buffer.WriteString(&#34;:&#34;)
                        }
                        first = false
                        buffer.WriteString(&#34;/var/lib/plash/index/&#34;)
                        buffer.WriteString(cont)
                        buffer.WriteString(&#34;/_data/root&#34;)
                }
                buffer.WriteString(&#34;,nosuid&#34;)
                overlayOpts := buffer.String()

                // mount directories
                call(&#34;mount&#34;, &#34;-t&#34;, &#34;overlay&#34;, &#34;overlay&#34;, &#34;-o&#34;, overlayOpts, mountpoint)
                call(&#34;mount&#34;, &#34;-t&#34;, &#34;proc&#34;, &#34;-o&#34;, &#34;rw,nosuid,nodev,noexec,relatime&#34;,
                        &#34;/proc&#34;, path.Join(mountpoint, &#34;/proc&#34;))
                call(&#34;mount&#34;, &#34;-t&#34;, &#34;none&#34;, &#34;-o&#34;, &#34;defaults,bind&#34;,
                        &#34;/home&#34;, path.Join(mountpoint, &#34;/home&#34;))
                call(&#34;mount&#34;, &#34;-t&#34;, &#34;none&#34;, &#34;-o&#34;, &#34;defaults,bind&#34;,
                        &#34;/etc/resolv.conf&#34;, path.Join(mountpoint, &#34;/etc/resolv.conf&#34;))
                call(&#34;mount&#34;, &#34;-t&#34;, &#34;none&#34;, &#34;-o&#34;, &#34;defaults,bind&#34;,
                        &#34;/tmp&#34;, path.Join(mountpoint, &#34;tmp&#34;))
                
                // makes mounpoint reusing possible
                err = os.Symlink(mountpoint, finalMountpoint)

                // its ok if the symlink was already generated by another process
                // we could cleanup the mounts at this point
                if ! os.IsExist(err){
                        checkErr(err, fmt.Sprintf(
                            ERR_SYMLINK_CONTEXT, mountpoint, finalMountpoint),
                        ERR_SYMLINK_HINT)
                }
        }

	pwd, err := os.Getwd()
        checkErr(err, ERR_GETWD_CONTEXT, ERR_GETWD_HINT)
	err = syscall.Chroot(finalMountpoint)
        checkErr(err,
           fmt.Sprintf(ERR_CHROOT_CONTEXT, finalMountpoint),
           ERR_CHROOT_HINT)
        err = syscall.Setreuid(callerUid, callerUid)
	err = os.Chdir(pwd)
	if err != nil {
		err = os.Chdir(&#34;/&#34;);
                checkErr(err, ERR_CHDIR_ROOT_CONTEXT, ERR_CHDIR_ROOT_HINT)
	}
	err = syscall.Exec(
                &#34;/usr/bin/env&#34;, append([]string{&#34;/usr/bin/env&#34;}, cmd...),
                os.Environ())
        checkErr(err, ERR_EXEC_CONTEXT, ERR_EXEC_HINT)
}
</code></pre>
</div>

</center>
</body>
</html>