#!/usr/bin/env python3
# usage: plash clean
# clean older containers

import os
import math
import shutil
from time import time
import sys
from plash import utils
from plash.unshare import unshare_if_user
import shutil
import subprocess

utils.handle_help_flag()
utils.assert_initialized()

plash_data = utils.get_plash_data()

unshare_if_user()


def remove_broken_links(dir):
    count = 0
    for file in os.listdir(dir):
        full_path = os.path.join(dir, file)
        try:
            os.stat(full_path)
        except FileNotFoundError:
            try:
                os.unlink(full_path)
                count += 1
            except FileNotFoundError:
                pass # race condition, link removed by another process
    return count

#
# Remove all broken links in $PLASH_DATA/index
#
index_dir = os.path.join(plash_data, 'index')
count = remove_broken_links(index_dir)
print('cleaned {} index links'.format(count), file=sys.stderr)

#
# Remove all broken links in $PLASH_DATA/cache_keys
#
cache_keys_dir = os.path.join(plash_data, 'cache_keys')
count = remove_broken_links(cache_keys_dir)
print('cleaned {} cache_keys links'.format(count), file=sys.stderr)

#
# Remove unused tmp dirs in $PLASH_DATA/tmp
#
deleted_tmps = 0
tmp = os.path.join(utils.get_plash_data(), 'tmp')
for file in os.listdir(tmp):
    abs_file = os.path.join(tmp, file)

    try:
        _, sid, pid, *_ = file.split('_')
        pid = int(pid)
    except ValueError:
        print('bad {}'.format(abs_file), file=sys.stderr)
        continue

    try:
        real_sid = os.getsid(pid)
    except ProcessLookupError:
        # no such pid, delete its tmp data
        delete = True
    else:
        if str(sid) == str(real_sid):
            # process still alive, don't delete its tmp dir
            delete = False
        else:
            # sid mismatch, its another one, delete
            delete = True

    if delete:
        # print('deleting {}'.format(abs_file), file=sys.stderr) # no noise
        shutil.rmtree(abs_file)
        deleted_tmps += 1
print('cleaned {} unused tmp directories'.format(deleted_tmps), file=sys.stderr)


##
## Delete some older containers
##
arg_percent = 50
modified_times = []
containers = os.listdir(index_dir)
containers.remove('0') # don't mess around with the special root container
for container_id in containers:
    index_path = os.path.join(index_dir, container_id)
    st = os.lstat(index_path)
    modified_times.append((container_id, st.st_mtime))

modified_times.sort(key=lambda i: (i[1], -int(i[0]))) # catch that ValuError in the int()
sorted_containers = [i[0] for i in modified_times]

delete_until_index = int(math.ceil((arg_percent / 100.0) * len(sorted_containers)))
delete_containers = sorted_containers[:delete_until_index]
deleted_counter = 0
for container_id in delete_containers:

    # delete the container
    index_path = os.path.join(index_dir, container_id)
    node = os.readlink(index_path)
    tmp = utils.mkdtemp()
    try:
        os.rename(node, tmp)
    except FileNotFoundError:
        # already deleted build, delete index
        os.unlink(index_path)
    shutil.rmtree(tmp)
    deleted_counter += 1

print('deleted {} of {} container(s)'.format(deleted_counter, len(sorted_containers)), file=sys.stderr)
