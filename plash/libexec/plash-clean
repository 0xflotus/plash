#!/usr/bin/env python3
# usage: plash clean
# clean older containers

import os
import shutil
from time import time
import sys
from plash import utils
import shutil
import subprocess

utils.handle_help_flag()
utils.assert_initialized()

plash_data = utils.get_plash_data()


def remove_broken_links(dir):
    count = 0
    for file in os.listdir(dir):
        full_path = os.path.join(dir, file)
        try:
            os.stat(full_path)
        except FileNotFoundError:
            try:
                os.unlink(full_path)
                count += 1
            except FileNotFoundError:
                pass # race condition, link removed by another process
    return count

#
# Remove all broken links in $PLASH_DATA/index
#
index_dir = os.path.join(plash_data, 'index')
count = remove_broken_links(index_dir)
print('cleaned {} index links'.format(count), file=sys.stderr)

#
# Remove all broken links in $PLASH_DATA/cache_keys
#
cache_keys_dir = os.path.join(plash_data, 'cache_keys')
count = remove_broken_links(cache_keys_dir)
print('cleaned {} cache_keys links'.format(count), file=sys.stderr)

#
# Remove unused tmp dirs in $PLASH_DATA/tmp
#
deleted_tmps = 0
tmp = os.path.join(utils.get_plash_data(), 'tmp')
for file in os.listdir(tmp):
    abs_file = os.path.join(tmp, file)

    try:
        _, sid, pid, *_ = file.split('_')
        pid = int(pid)
    except ValueError:
        print('bad {}'.format(abs_file), file=sys.stderr)
        continue

    try:
        real_sid = os.getsid(pid)
    except ProcessLookupError:
        # no such pid, delete its tmp data
        delete = True
    else:
        if str(sid) == str(real_sid):
            # process still alive, don't delete its tmp dir
            delete = False
        else:
            # sid mismatch, its another one, delete
            delete = True

    if delete:
        # print('deleting {}'.format(abs_file), file=sys.stderr) # no noise
        shutil.rmtree(abs_file)
        deleted_tmps += 1
print('cleaned {} unused tmp directories'.format(deleted_tmps), file=sys.stderr)


modified_times = []
for container_id in os.listdir(index_dir):
    index_path = os.path.join(index_dir, container_id)
    st = os.lstat(index_path)
    modified_times.append((container_id, st.st_mtime))

modified_times.sort(key=lambda i: i[1])
from pprint import pprint
pprint(modified_times)

##
## Delete some older containers
##
#arg_percent = 30
#def cmp(obj):
#    try:
#        return -int(obj)
#    except ValueError:
#        return 1
#index_dir = os.path.join(plash_data, 'index')
#indexes = os.listdir(index_dir)
#indexes.sort(key=cmp)
#delete_before_counter = round((arg_percent / 100.0) * len(indexes))
#for counter, container_id in enumerate(indexes):
#
#    if container_id == '0': # the special root container, don't touch that one
#        continue
#
#    if counter >= delete_before_counter:
#        break
#
#    index_path = os.path.join(index_dir, container_id)
#    node = os.readlink(index_path)
#    tmp = utils.mkdtemp()
#    try:
#        os.rename(node, tmp)
#    except FileNotFoundError:
#        # already deleted build, delete index
#        os.unlink(index_path)
#    shutil.rmtree(tmp)
#print('deleted {} of {} containers'.format(counter, len(indexes)), file=sys.stderr)
