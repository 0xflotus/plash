#!/usr/bin/env python3
# usage: plash shrink
# Delete half of the less used containers

import os
import math
import sys
import shutil
import subprocess
from plash import unshare, utils
import tempfile

# allows changing subuids in the fs
unshare.unshare_if_user()

DELETE_PERCENT = 50

modified_times = []
index_dir = os.path.join(utils.get_plash_data(), 'index')
containers = os.listdir(index_dir)
containers.remove('0') # don't mess around with the special root container

children_count = {}
nodepaths = {}
for container_id in list(containers):
    try:
        nodepath = os.readlink(os.path.join(index_dir, container_id))
        os.stat(nodepath) # raises the file not found if containers was deleted
    except FileNotFoundError:
        # broken link, it's `plash clean`s responsability to clean that
        continue
    nodepaths[container_id] = nodepath
    components = nodepath.split('layers/')[-1].split('/')
    children_count.setdefault(container_id, 0)
    for parent in components[:-1]: # not a parent but a sibling or something like that
        children_count.setdefault(parent, 0)
        children_count[parent] += 1
    
total_containers = len(children_count)
delete_quota = math.ceil(total_containers * 0.5)
already_deleted = 0
mastertmp = utils.mkdtemp()
for container_id, children in sorted(children_count.items(), key=lambda i: int(i[0])):
    affected = children + 1

    if already_deleted >= delete_quota:
        break

    if already_deleted + affected <= delete_quota:

        tmp = tempfile.mkdtemp(dir=mastertmp)
        try:
            os.rename(nodepaths[container_id], tmp)
        except FileNotFoundError:
            continue # we or another process already deleted it
        already_deleted += affected

print('deleted {} of {} containers'.format(already_deleted, total_containers), file=sys.stderr)
print('cleaning up...')
shutil.rmtree(mastertmp)
