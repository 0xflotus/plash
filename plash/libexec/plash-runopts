#!/usr/bin/env python3
#
# usage: plash runopts [ -b BIND ] [ -c CHANGES ] CONTAINER [ CMD1 [ CMD2 ... ] ]
# Run a container with extra options

from getopt import getopt
import os
import re
import sys
import tempfile
from subprocess import CalledProcessError, check_call

from plash import utils
from plash.unshare import unshare_if_root, unshare_if_user
from plash.utils import (assert_initialized, catch_and_die, die,
                         get_default_shell, handle_help_flag, mkdtemp)

LOGIN_DEFS_RE = re.compile(r'^\s*ENV_PATH\s+(?:PATH=){0,1}(.*?)\s*$',
                           re.MULTILINE)
FALLBACK_PATH = '/bin:/usr/bin'

handle_help_flag()
assert_initialized()

user_opts, user_args = getopt(sys.argv[1:], 'b:nc:')
container, *cmd = user_args

#
# find out the mountpoint
#
if not os.getuid() and os.environ.get('PLASH_NO_UNSHARE'):
    mountpoint = tempfile.mkdtemp(dir='/var/tmp', prefix='plash-mountpoint-{}-'.format(os.getpid()))
else:
    mountpoint = os.path.join(utils.get_plash_data(), 'mnt')

#
# enter different namespace
#
unshare_if_root()
unshare_if_user()

#
# find the changesdir opt and mount container
#
mounted = False
for opt_key, opt_value in user_opts:
    if opt_key == '-c':
        changesdir = opt_value
        with catch_and_die([CalledProcessError], silent=True):
            check_call(['plash-mount', container, mountpoint, changesdir])
        mounted = True
        break
if not mounted:
    die('runopts: missing -c option')

#
# mount requested directories
#
for opt_key, opt_value in user_opts:
    if opt_key == '-b':
        check_call([
            'mount', '--rbind', opt_value,
            os.path.join(mountpoint, opt_value.lstrip('/'))
        ])


#
# setup chroot and exec inside it
#

pwd_at_start = os.getcwd()

# I had problems opening the files after the chroot (LookupError: unknown encoding: ascii)
default_root_shell = get_default_shell(os.path.join(mountpoint, 'etc/passwd'))

# read PATH from /etc/login.defs if available
try:
    with open(os.path.join(mountpoint, 'etc/login.defs')) as f:
        match = LOGIN_DEFS_RE.findall(f.read())
except FileNotFoundError:
    match = None
os.environ['PATH'] = match[-1] if match else FALLBACK_PATH

os.chroot(mountpoint)
try:
    os.chdir(pwd_at_start)
except (ValueError, OSError):
    os.chdir('/')
if not cmd:
    cmd = [default_root_shell]

with catch_and_die([OSError]):
    try:
        os.execlp(cmd[0], *cmd)
    except FileNotFoundError:
        sys.stderr.write('{}: command not found\n'.format(cmd[0]))
        sys.exit(127)
