#!/usr/bin/env python3
#
# usage: plash runopts -c CONTAINER -d CHANGESDIR  [ -m MOUNT ] CMD1 [ CMD2 ... ] ]
# Run a container with low level options.
# Usually you'll want to use `plash run` instead.

import getopt
import os
import re
import sys
import tempfile
from subprocess import CalledProcessError, check_call

from plash import utils
from plash.unshare import unshare_if_root, unshare_if_user
from plash.utils import (assert_initialized, catch_and_die, die,
                         handle_help_flag, mkdtemp)

LOGIN_DEFS_RE = re.compile(r'^\s*ENV_PATH\s+(?:PATH=){0,1}(.*?)\s*$',
                           re.MULTILINE)
FALLBACK_PATH = '/bin:/usr/bin'

handle_help_flag()
assert_initialized()

with utils.catch_and_die([getopt.GetoptError], debug='runopts'):
    user_opts, user_args = getopt.getopt(sys.argv[1:], 'c:d:m:')

#
# find out the mountpoint
#
if not os.getuid() and os.environ.get('PLASH_NO_UNSHARE'):
    mountpoint = tempfile.mkdtemp(dir='/var/tmp', prefix='plash-mountpoint-{}-'.format(os.getpid()))
else:
    mountpoint = os.path.join(utils.get_plash_data(), 'mnt')

#
# enter different namespace
#
unshare_if_root()
unshare_if_user()

#
# parse and interpret user options
#
container = False
mounted = False
for opt_key, opt_value in user_opts:

    if opt_key == '-c':
        container = opt_value

    elif opt_key == '-d':
        if not container:
            die('runopts: -c option must come before -d option')
        with catch_and_die([CalledProcessError], silent=True):
            check_call(['plash-mount', container, mountpoint, opt_value])
        mounted = True

    if opt_key == '-m':
        check_call([
            'mount', '--rbind', opt_value,
            os.path.join(mountpoint, opt_value.lstrip('/'))
        ])

if not mounted and container:
    die('runopts: missing -d option')
elif not mounted:
    die('runopts: missing -c and -d options')

#
# setup chroot and exec inside it
#

pwd_at_start = os.getcwd()

# I had problems opening the files after the chroot (LookupError: unknown encoding: ascii)

# read PATH from /etc/login.defs if available
try:
    with open(os.path.join(mountpoint, 'etc/login.defs')) as f:
        match = LOGIN_DEFS_RE.findall(f.read())
except FileNotFoundError:
    match = None
os.environ['PATH'] = match[-1] if match else FALLBACK_PATH

if not user_args:
    cmd = [utils.get_default_shell(os.path.join(mountpoint, 'etc/passwd'))]
else:
    cmd = user_args

os.chroot(mountpoint)
try:
    os.chdir(pwd_at_start)
except (ValueError, OSError):
    os.chdir('/')

with catch_and_die([OSError]):
    try:
        os.execlp(cmd[0], *cmd)
    except FileNotFoundError:
        sys.stderr.write('{}: command not found\n'.format(cmd[0]))
        sys.exit(127)
