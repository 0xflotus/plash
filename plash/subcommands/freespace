#!/usr/bin/env python3

from __future__ import print_function

import atexit
import os
import subprocess
import sys
from datetime import datetime
from os.path import join
from pprint import pprint
from shutil import disk_usage, rmtree
from tempfile import mkdtemp
from time import sleep

BUILDS_DIR = '/var/lib/plash'
TMP_DIR = '/tmp'
DELETE_RATIO = 0.43

CONFIRM = """WARNING: This can put containerized filesystems of other plash instances in a not defined state.
Type "yes" if you feel comfortable about this.
Ok? """


"""
file locking:
freespace writes a lockfile, this garantees, that not plash build process will 
will use the builds for 20 seconds. after 20 seconds waiting plash build process will delete the lockfile

This process will self terminate in 19 seconds via signal.settitmeout or so
"""

if not os.access(BUILDS_DIR, os.W_OK):
    print('No write access to ' + BUILDS_DIR)
    sys.exit(1)

continue_ = input(CONFIRM) if not '--yes' in sys.argv[1:] else 'yes'
if not continue_.lower() == 'yes':
    sys.exit(1)


usages = []
for  dirpath, dirs, files in os.walk(BUILDS_DIR):
    if dirpath != BUILDS_DIR and os.path.basename(dirpath) != 'children':
        last_modified = os.path.getmtime(dirpath)
        score = (last_modified, -1 * len(dirpath))
        usages.append((dirpath, score))

    # don't dive into that one
    if 'payload' in dirs:
        dirs.remove('payload')

# tempdir = mkdtemp(prefix='deleteme-')
# print(tempdir)
# for counter, (path, _) in enumerate(usages):
#     move_to = join(tempdir, str(counter))
#     try:
#         print(path, move_to)
#         os.rename(path, move_to)
#     except FileNotFoundError:
#         pass # probably a parent already was removed

# sys.exit(0)

sorted_usages = sorted(usages, key=lambda i: i[1]) # itemgetter?
# pprint([(a, datetime.fromtimestamp(b).strftime("%Y-%m-%d %H:%M:%S")) for (a, b) in sorted_usages])

layers_num = len(usages)
delete_layers_num = int(round(0.5 * layers_num)) # delete 50% of all layers
sorted_usages = sorted(usages, key=lambda i: i[1]) # itemgetter?

# # print(sorted_usages)
# def get_size(path):
#     out = subprocess.check_output(['du', '-sh', path])
#     return out.split()[0]

# https://stackoverflow.com/questions/1094841/reusable-library-to-get-human-readable-version-of-file-size
def sizeof_fmt(num, suffix='B'):
    for unit in ['','Ki','Mi','Gi','Ti','Pi','Ei','Zi']:
        if abs(num) < 1024.0:
            return "%3.1f%s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)

def getsize(path):
    out = subprocess.check_output(['du', '-s', path])
    return int(out.split()[0]) * 1024

size_beginning = getsize(BUILDS_DIR)
for delete_build, _ in sorted_usages:
    tmpdir = mkdtemp(dir=TMP_DIR, suffix='.{}'.format(os.getpid()))
    # print('Deleting: {}'.format(delete_build))

    if not os.path.exists(delete_build): # a parent may be deleted
        continue

    nice_for_user = sizeof_fmt(getsize(delete_build))
    print('Freeing {} at {}'.format(nice_for_user, delete_build))

    try:
        os.rename(delete_build, join(tmpdir, '_')) # use something atomic
    except FileNotFoundError:
        pass # parent already deleted by this process or another parallel freespace call
    rmtree(tmpdir)

    size_now = getsize(BUILDS_DIR)
    if size_now / size_beginning <= DELETE_RATIO:
        print()
        print("Previous disk usage: {}".format(sizeof_fmt(size_beginning)))
        print(" Current disk usage: {}".format(sizeof_fmt(size_now)))
        break

    # print(sizeof_fmt(getsize(delete_build)))
    # print(os.statvfs(delete_build))
    # try:
    #     os.rename(delete_build, join(tmpdir, '_')) # use something atomic
    # except FileNotFoundError:
    #     pass # parent already deleted by this process or another parallel freespace call
    # rmtree(tmpdir)
